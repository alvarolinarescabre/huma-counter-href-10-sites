version: 0.2

env:
  variables:
    ARGOCD_REPO: "alvarolinarescabre/huma-counter-href-10-sites"
    ARGOCD_APP_NAME: "huma-counter-href-10-sites"
    ARGOCD_PUSH_BRANCH: "main"
    APP_GITHUB_REPO: "alvarolinarescabre/huma-counter-href-10-sites"

phases:
  install:
    commands:
      - echo Installing dependencies...
      - yum install -y git jq || apt-get update && apt-get install -y git jq || true
  build:
    commands:
      - |
        echo Reading imagedefinitions.json
        # Locate imagedefinitions.json produced by the build stage. It may be placed
        # in a secondary artifact path under /codebuild/output/src*/src/s3/... or
        # in the working dir. Search common locations.
        IMG_PATH=$(find /codebuild/output -maxdepth 5 -type f -name imagedefinitions.json -print -quit 2>/dev/null || true)
        if [ -z "$IMG_PATH" ]; then
          IMG_PATH=$(find . -maxdepth 6 -type f -name imagedefinitions.json -print -quit 2>/dev/null || true)
        fi
        if [ -z "$IMG_PATH" ]; then
          echo "imagedefinitions.json not found"
          exit 0
        fi
        echo "Using imagedefinitions.json at: $IMG_PATH"
        # Try parsing with jq, but fall back to a regex if jq fails on malformed JSON
        IMAGE_URI=$(jq -r '.[0].imageUri' "$IMG_PATH" 2>/tmp/jqerr || true)
        if [ -z "$IMAGE_URI" ]; then
          IMAGE_URI=$(grep -oP '"imageUri"\s*:\s*"\K[^"]+' "$IMG_PATH" | head -n1 || true)
        fi
        echo "IMAGE_URI=$IMAGE_URI"
        IMAGE_TAG=$(echo "$IMAGE_URI" | awk -F: '{print $NF}')
        IMAGE_NAME=$(echo "$IMAGE_URI" | sed 's/:.*$//')
        echo "IMAGE_NAME=$IMAGE_NAME IMAGE_TAG=$IMAGE_TAG"

        echo "Cloning app repo: $APP_GITHUB_REPO"
         git clone "https://github.com/$APP_GITHUB_REPO.git" app_src
        if [ -n "$IMAGE_TAG" ] && [ "$IMAGE_TAG" != "latest" ]; then
          (cd app_src && git checkout "$IMAGE_TAG" || true)
        fi

        echo "Cloning ArgoCD manifests repo: $ARGOCD_REPO"
         git clone "https://github.com/$ARGOCD_REPO.git" argocd_repo

        # Locate k8s manifests in the app repo. Prefer a 'k8s/base' folder but
        # fall back to any directory containing a kustomization.yaml
        APP_K8S_DIR=""
        if [ -d "app_src/k8s/base" ]; then
          APP_K8S_DIR="app_src/k8s/base"
        else
          KUSTOM=$(find app_src -type f -name kustomization.yaml -print -quit 2>/dev/null || true)
          if [ -n "$KUSTOM" ]; then
            APP_K8S_DIR=$(dirname "$KUSTOM")
          fi
        fi

        TARGET_DIR="argocd_repo/infraestructure/k8s/base"
        rm -rf "$TARGET_DIR" || true
        mkdir -p "$TARGET_DIR"
        echo "Copying k8s manifests from app to ArgoCD repo (source: ${APP_K8S_DIR:-not found})"
        if [ -n "$APP_K8S_DIR" ]; then
          cp -r "$APP_K8S_DIR"/* "$TARGET_DIR/" || true
        else
          echo "No k8s manifests found in app repo; skipping copy"
        fi

        KUSTOMIZATION="$TARGET_DIR/kustomization.yaml"
        if [ -f "$KUSTOMIZATION" ]; then
          echo "Updating kustomization with image name and tag"
          sed -i "s|name: .*|name: $IMAGE_NAME|" "$KUSTOMIZATION" || true
          sed -i "s|newTag: .*|newTag: $IMAGE_TAG|" "$KUSTOMIZATION" || true
        fi

        cd argocd_repo
        git config user.email "codebuild@local"
        git config user.name "codebuild"
        git add "infraestructure/k8s" || git add "$TARGET_DIR" || true
        if git diff --staged --quiet; then
          echo "No changes to push"
          exit 0
        fi
        git commit -m "argocd-update: update ${ARGOCD_APP_NAME} image to ${IMAGE_TAG}" || true
        # If a GITHUB_TOKEN is provided in the environment, use it for an
        # authenticated HTTPS push; otherwise attempt to push using the
        # existing origin (will fail if write access is required).
        if [ -n "$GITHUB_TOKEN" ]; then
          git remote set-url origin "https://$GITHUB_TOKEN@github.com/$ARGOCD_REPO.git"
        fi
        git push origin HEAD:${ARGOCD_PUSH_BRANCH:-main} || true

artifacts:
  files:
    - '**/*'
